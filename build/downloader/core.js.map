{"version":3,"sources":["../../src/downloader/core.js"],"names":["fs","require","path","Url","request","requestHead","head","getMetadata","url","headUrl","threads","savePath","saveDir","pipe","x","response","statusCode","parseInt","headers","filesize","ranges","join","process","cwd","basename","parse","meta","sudPath","writeFile","JSON","stringify","readMetadata","rawMeta","makeRequests","meta$","options","rangeHeaders","request$s","Array","length","forEach","rangeHeader","index","Object","assign","range","requestOptions","timeout","getThreadPositions","requestsAndMeta$","requestsAndMeta","transformedRequest$s","map","request$","partialFile","startPos","writeStream","createWriteStream","flags","start","writeToStream","write","bind","data","Buffer","byteLength","threadPosition","chunkSize","end","mergedTransformedRequests$","getDownloadProgressInfo","threadPositions$","throttleRate","acc","initialDownloadProgressInfo","downloadProgressInfo"],"mappings":"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","sourcesContent":["const fs = require('graceful-fs')\nconst path = require('path')\nconst Url = require('url')\nconst request = require('request')\nimport { bindNodeCallback, from, of, throwError, empty, bindCallback, Observable } from 'rxjs'\nimport { map, tap, filter, scan, finalize, mergeAll, concatMap, mergeMap, pluck, throttleTime, concat } from 'rxjs/operators'\nimport { sudPath, calculateRanges, getRangeHeaders, fsReadFile, createRequest, partialPath, getLocalFilesize, rebuildFiles, getInitialDownloadProgressInfo, calculateDownloadProgressInfo  } from './util'\n\n//the observable created from the requestHead function will emit the array [response, ''] if no error is caught\n//because the parameters for the request callback are (err, response, body) and body is empty\n//see https://rxjs.dev/api/index/function/bindNodeCallback for more info\nconst requestHead = bindNodeCallback(request.head)\n\nexport function getMetadata(url, headUrl, threads, savePath, saveDir) {\n\treturn requestHead(headUrl).pipe(\n\t\tmergeMap(x => {\n\t\t\tvar response = x[0]\n\t\t\tvar { statusCode } = response\n\t\t\tif(statusCode >= 400 && statusCode <= 512) {\n\t\t\t\treturn throwError(response)\n\t\t\t} else {\n\t\t\t\treturn of(parseInt(response.headers['content-length']))\n\t\t\t}\n\t\t}),\n\t\tmap(filesize => {\n\n\t\t\tvar ranges = calculateRanges(filesize, threads)\n\n\t\t\tsavePath = savePath || path.join(saveDir || process.cwd(), path.basename(Url.parse(url).path))\n\t\t\t\n\t\t\tvar meta = {\n\t\t\t\turl,\n\t\t\t\tsavePath,\n\t\t\t\tsudPath: sudPath(savePath),\n\t\t\t\tfilesize,\n\t\t\t\tranges\n\t\t\t}\n\n\t\t\treturn meta\n\t\t}),\n\n\t\t//write data to .sud meta file side effect\n\t\ttap(meta => {\n\t\t\tfs.writeFile(meta.sudPath, JSON.stringify(meta))\n\t\t})\n\t)\n}\n\nexport function readMetadata(sudPath) {\n\treturn fsReadFile(sudPath).pipe(\n\t\tmap(rawMeta => JSON.parse(rawMeta))\n\t)\n}\n\n//calculate ranges based on existing .PARTIAL files\n//and transform the meta object into an object holding an array of request observables\n//and the meta data object\nexport function makeRequests(meta$, options) {\n\treturn meta$.pipe(\n\t\tmap(meta => {\n\n\t\t\tvar { url, savePath, ranges } = meta\n\t\t\tvar rangeHeaders = getRangeHeaders(savePath, ranges)\n\t\t\tvar request$s = new Array(rangeHeaders.length)\n\n\t\t\trangeHeaders.forEach((rangeHeader, index) => {\n\t\t\t\tif(rangeHeader) {\n\t\t\t\t\tvar headers = Object.assign(options.headers || {}, { range: rangeHeader })\n\t\t\t\t\tvar requestOptions = { headers, timeout: options.timeout }\n\t\t\t\t\trequest$s[index] = createRequest(url, requestOptions)\n\t\t\t\t} else {\n\t\t\t\t\trequest$s[index] = empty()\n\t\t\t\t}\n\t\t\t})\n\n\t\t\treturn { request$s, meta }\n\t\t})\n\t)\n}\n\n//write to buffer within and rebuild upon completion\n//a separate meta$ observable created from the passed meta object is concatenated to the front\n//the first item emitted from the returned variable will be the meta object\nexport function getThreadPositions(requestsAndMeta$) {\n\treturn requestsAndMeta$.pipe(\n\t\tconcatMap(requestsAndMeta => {\n\n\t\t\tvar { request$s, meta, meta: { savePath, ranges } } = requestsAndMeta\n\n\t\t\tvar transformedRequest$s = request$s.map((request$, index) => {\n\n\t\t\t\tvar partialFile = partialPath(savePath, index)\n\t\t\t\tvar startPos = ranges[index][0] + getLocalFilesize(partialFile)\n\t\t\t\tvar writeStream = fs.createWriteStream(partialFile, { flags: 'a', start: startPos })\n\t\t\t\tvar writeToStream = bindCallback(writeStream.write).bind(writeStream)\n\t\t\t\treturn request$.pipe(\n\t\t\t\t\tfilter(x => x),\n\t\t\t\t\t//the nested concatMap ensures the buffer is written and that this writing completes\n\t\t\t\t\t//before the thread position is updated\n\t\t\t\t\t//this is necessary to ensure the .PARTIAL files rebuild correctly\n\t\t\t\t\t//we need it to be nested as the values emitted by writeToStream are not useful\n\t\t\t\t\tconcatMap(data => \n\t\t\t\t\t\tof(data).pipe(\n\t\t\t\t\t\t\tconcatMap(data => writeToStream(data)),\n\t\t\t\t\t\t\tmap(() => Buffer.byteLength(data))\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\tscan((threadPosition, chunkSize) => threadPosition + chunkSize, startPos),\n\t\t\t\t\tfinalize(() => writeStream.end())\n\t\t\t\t)\n\t\t\t})\n\n\t\t\t//setup mergedTransformedRequests$ to rebuild on completion of ALL inner observables\n\t\t\t//merge flattens the higher-order observable into a single observable\n\t\t\tvar mergedTransformedRequests$ = from(transformedRequest$s).pipe(\n\t\t\t\tmergeAll(),\n\t\t\t\t//once the source observable finishes, rebuild the files\n\t\t\t\tconcat(rebuildFiles(meta))\n\t\t\t)\n\n\t\t\tvar meta$ = of(meta)\n\n\t\t\treturn of(meta$, mergedTransformedRequests$)\n\t\t}),\n\n\t\t//merge the meta observable and the already flattened position observables into one observable\n\t\tmergeAll()\n\t)\n}\n\n//use the meta data object (first item to be emitted) and the thread positions\n//to calculate various information about the download progress\nexport function getDownloadProgressInfo(threadPositions$, throttleRate) {\n\treturn threadPositions$.pipe(\n\t\tthrottleTime(throttleRate),\n\t\tscan((acc, threadPosition) => {\n\t\t\t//initialise the accumulator to hold the meta data object and initial download progress info\n\t\t\tif(acc == 0) {\n\t\t\t\tvar meta = threadPosition\n\t\t\t\tvar initialDownloadProgressInfo = getInitialDownloadProgressInfo(meta)\n\t\t\t\t//the downloadProgressInfo field is also set to the meta data object so that\n\t\t\t\t//the meta data object is available (as the first item emitted) once plucked\n\t\t\t\tacc = { meta, initialDownloadProgressInfo, downloadProgressInfo: meta }\n\t\t\t} else {\n\t\t\t\t//threadPosition is an actual thread position and not the meta data object, calculate the download progress info\n\t\t\t\tvar downloadProgressInfo = calculateDownloadProgressInfo(acc, threadPosition)\n\t\t\t\t//set initialDownloadProgressInfo to null so the next iteration of calculateDownloadProgressInfo\n\t\t\t\t//knows to use the accumulator's downloadProgressInfo instead\n\t\t\t\tacc = Object.assign(acc, { initialDownloadProgressInfo: null, downloadProgressInfo })\n\t\t\t}\n\n\t\t\treturn acc\n\t\t}, 0),\n\t\tpluck('downloadProgressInfo')\n\t)\n}"],"file":"core.js"}