{"version":3,"sources":["../../src/scheduler/index.js"],"names":["SuDScheduler","autoStart","maxConcurrentDownloads","downloadOptions","options","key","locations","userObserver","next","taskQueueItem","status","params","push","start","startDownload","wrappedObserver","dlOptions","Object","assign","dlSubscription","subscribe","stop","unsubscribe","forEach","activeCount","pauseDownload","filter","length","undefined","nextExists","findIndex","find","index","splice","userObservable","error","complete","module","exports"],"mappings":"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","sourcesContent":["import { startDownload, killFiles, sudPath } from '../downloader/'\n\nconst SuDScheduler = class {\n\n\t//holds all download tasks as objects with status and params fields\n\t#taskQueue = []\n\t//holds objects that have a key and a subscription field\n\t//the subscription field holds the flowing download subscription\n\t#downloadSubscriptions = {}\n\n\toptions = {}\n\n\t//set maxConcurrentDownloads to 0 for unlimited concurrent downloads\n\tconstructor({ autoStart = true, maxConcurrentDownloads = 4, downloadOptions = {} } = {}) {\n\t\tthis.options.autoStart = autoStart\n\t\tthis.options.maxConcurrentDownloads = maxConcurrentDownloads\n\t\tthis.options.downloadOptions = downloadOptions\n\t}\n\n\t//PUBLIC METHODS\n\n\t//returns the task queue\n\tget taskQueue() {\n\t\treturn this.#taskQueue\n\t}\n\n\tget queuedCount() {\n\t\treturn this.#countTasks('queued')\n\t}\n\n\tget activeCount() {\n\t\treturn this.#countTasks('active')\n\t}\n\t\n\tget stoppedCount() {\n\t\treturn this.#countTasks('stopped')\n\t}\n\n\tget taskCount() {\n\t\treturn this.#countTasks()\n\t}\n\n\t//adds a download task to the queue\n\t//an observer object MUST be provided as the 3rd or 4th positional argument\n\t//this method is used to add new downloads or resume from pre existing .sud files\n\t//if the intention is to queue a download from a pre existing .sud file, locations should be\n\t//the .sud file path and options.threads will be unnecessary\n\t//key should be unique\n\tqueueDownload(key, locations, options, userObserver) {\n\t\tif(!this.#keyIsUnique(key)) throw('KEYS MUST BE UNIQUE')\n\n\t\t//if options is omitted, assume it is the observer\n\t\tif(options.next) var userObserver = options\n\n\t\tvar taskQueueItem = {\n\t\t\tkey,\n\t\t\tstatus: 'queued',\n\t\t\tparams: { locations, options: options.next ? {} : options },\n\t\t\tuserObserver\n\t\t}\n\t\tthis.#taskQueue.push(taskQueueItem)\n\t\t\n\t\tthis.#tryNextInQueue()\n\t\t\n\t\tif(!this.options.autoStart) {\n\t\t\t//convenience object to allow the user to dot chain start()\n\t\t\treturn {\n\t\t\t\tstart: () => this.startDownload(key)\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t//starts a download task, or resumes an active download\n\t//starting a new download task using this methods will ignore\n\t//the max concurrent download limit\n\t//returns false if a download task with the provided key doesn't exist\n\t//returns true otherwise\n\tstartDownload(key) {\n\t\tvar taskQueueItem = this.#getTaskQueueItem(key)\n\t\tif(!taskQueueItem) return false\n\t\tvar { userObserver, params: { locations, options } } = taskQueueItem\n\t\t\n\t\ttaskQueueItem.status = 'active'\n\n\t\tvar wrappedObserver = this.#wrapInternalObserver(key, userObserver)\n\t\tvar dlOptions = Object.assign(this.options.downloadOptions, options)\n\t\tvar dlSubscription = startDownload(locations, dlOptions).subscribe(wrappedObserver)\n\t\tthis.#downloadSubscriptions[key] = dlSubscription\n\n\t\treturn true\n\t}\n\n\t//pauses an active download and stops if the second parameter is true\n\t//an active download that is paused is still considered active\n\t//stopping a download task allows for more tasks to be auto started\n\t//as a stopped task is not considered active\n\t//returns false if the download task is already paused/stopped or has not yet started or does not exist\n\t//returns true otherwise\n\tpauseDownload(key, stop = false) {\n\t\tvar taskQueueItem = this.#getTaskQueueItem(key)\n\t\tvar dlSubscription = this.#downloadSubscriptions[key]\n\t\tif(!dlSubscription || !taskQueueItem) return false\n\t\t\n\t\ttaskQueueItem.status = stop ? 'stopped' : taskQueueItem.status\n\n\t\tdlSubscription.unsubscribe()\n\t\tdelete this.#downloadSubscriptions[key]\n\n\t\tthis.#tryNextInQueue()\n\n\t\treturn true\n\t}\n\n\t//stops an active download and removes associated .sud and .PARTIAL files, or\n\t//removes queued download task from queue\n\t//returns false if a download task with the provided key doesn't exist\n\t//returns true otherwise\n\tkillDownload(key) {\n\t\tvar taskQueueItem = this.#getTaskQueueItem(key)\n\t\tif(!taskQueueItem) return false\n\t\tvar { status } = taskQueueItem\n\t\t\n\t\tvar dlSubscription = this.#downloadSubscriptions[key]\n\t\t\n\t\tif(dlSubscription) {\n\t\t\tthis.#downloadSubscriptions[key].unsubscribe()\n\t\t\tdelete this.#downloadSubscriptions[key]\n\t\t}\n\n\t\tthis.#removeTaskQueueItem(key)\n\t\tkillFiles(key)\n\n\t\tthis.#tryNextInQueue()\n\t\t\n\t\treturn true\n\t}\n\n\t//starts downloading as many as possible, limited by the maxConcurrentDownloads option\n\tstartQueue() {\n\t\tthis.#taskQueue.forEach(taskQueueItem => {\n\t\t\tif(taskQueueItem.status == 'stopped') {\n\t\t\t\ttaskQueueItem.status = 'queued'\n\t\t\t}\n\t\t})\n\n\t\tvar activeCount = this.#countStatus('active')\n\t\tvar { maxConcurrentDownloads } = this.options\n\t\twhile(activeCount < maxConcurrentDownloads && this.#taskQueue[activeCount + 1]) {\n\t\t\tvar { key, status } = this.#taskQueue[activeCount]\n\t\t\tif(status == 'active') return\n\t\t\tthis.startDownload(key)\n\t\t\tactiveCount++\n\t\t}\n\t}\n\n\t//pauses/stops all active downloads\n\tpauseAll(stop = false) {\n\t\tthis.#taskQueue.forEach(taskQueueItem => this.pauseDownload(taskQueueItem.key, stop))\n\t}\n\n\t//returns the status of the download task associated with the provided key or false if the download task doesn't exist\n\tgetStatus(key) {\n\t\tvar taskQueueItem = this.#getTaskQueueItem(key)\n\t\tif(!taskQueueItem) return false\n\t\treturn taskQueueItem.status\n\t}\n\n\t//PRIVATE METHODS\n\t#countStatus(status) {\n\t\treturn this.#taskQueue.filter(taskQueueItem => taskQueueItem.status == status).length\n\t}\n\n\t#countTasks() {\n\t\treturn this.#taskQueue.length\n\t}\n\n\t#keyIsUnique(key) {\n\t\treturn this.#getTaskQueueItem(key) == undefined\n\t}\n\n\t//checks if the conditions for starting a new task are met\n\t#canStartNext() {\n\t\tvar { maxConcurrentDownloads } = this.options\n\t\tvar nextExists = this.#taskQueue.findIndex(taskQueueItem => taskQueueItem.status == 'queued') != -1\n\t\treturn (maxConcurrentDownloads == 0 || this.#countStatus('active') < maxConcurrentDownloads) && nextExists\n\t}\n\n\t//starts the next task in queue\n\t#startNextInQueue() {\n\t\tvar { key } = this.#taskQueue.find(taskQueueItem => taskQueueItem.status == 'queued')\n\t\tthis.startDownload(key)\n\t}\n\n\t//checks for start new condition and starts next if met\n\t#tryNextInQueue() {\n\t\tif(this.options.autoStart && this.#canStartNext()) {\n\t\t\tthis.#startNextInQueue()\n\t\t}\n\t}\n\n\t#getTaskQueueItem(key) {\n\t\treturn this.#taskQueue.find(taskQueueItem => taskQueueItem.key == key)\n\t}\n\n\t#removeTaskQueueItem(key) {\n\t\tvar index = this.#taskQueue.findIndex(taskQueueItem => taskQueueItem.key == key)\n\t\tthis.#taskQueue.splice(index, 1)\n\t}\n\n\t//the real observer used with the observable returned by the downloader's startDownload function\n\t//this observer calls the functions of the user defined observer, but also facilitates\n\t//necessary maintenance tasks such as updating the download task's status and cleaning up\n\t#wrapInternalObserver(key, userObservable) {\n\t\tvar taskQueueItem = this.#getTaskQueueItem(key)\n\t\tvar { status } = taskQueueItem\n\t\treturn {\n\t\t\tnext: userObservable.next,\n\t\t\terror: userObservable.error,\n\t\t\tcomplete: () => {\n\t\t\t\tuserObservable.complete()\n\n\t\t\t\t//remove the useless dead subscription and internal reference\n\t\t\t\tthis.#removeTaskQueueItem(key)\n\t\t\t\tdelete this.#downloadSubscriptions[key]\n\t\t\t\t//emit event for empty queue\n\t\t\t\tthis.#tryNextInQueue()\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nmodule.exports = SuDScheduler\n"],"file":"index.js"}